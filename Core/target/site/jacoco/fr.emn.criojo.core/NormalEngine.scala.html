<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NormalEngine.scala</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core</a> &gt; <a href="index.html" class="el_package">fr.emn.criojo.core</a> &gt; <span class="el_source">NormalEngine.scala</span></div><h1>NormalEngine.scala</h1><pre class="source lang-java linenums">package fr.emn.criojo.core

/*
 * Created by IntelliJ IDEA.
 * User: Jonathan
 * Date: 28/06/12
 * Time: 09:35
 */

import collection.mutable.{ListBuffer, HashMap}
import datatype.{ BottomValuation, Valuation, Variable}

/**
 * The NormalEngine trait
 * @define THIS A
 * @define PARENT no other class
 * @define RESULT 3
 */
trait NormalEngine extends Engine {

<span class="fc" id="L21">  var isRunning:Boolean = false</span>

<span class="fc" id="L23">  val solution:Solution = new Solution()</span>

<span class="fc" id="L25">  var indexAtomPartialStateExecution:HashMap[Atom, ListBuffer[PartialStateExecution]] = HashMap()</span>

<span class="fc" id="L27">  def createRule(h: Head, b: Body, g: Guard, scope: Set[Variable]) = new NormalRule(h, b, g, scope, this)</span>

<span class="fc" id="L29">  override def reactionStrategy: ReactionStrategy = new LocalReactionStrategy()</span>

  def addToExecutionIndex(a:Atom, pe:PartialStateExecution) {
<span class="fc bfc" id="L32" title="All 2 branches covered.">    if(!indexAtomPartialStateExecution.contains(a)) {</span>
<span class="fc" id="L33">      indexAtomPartialStateExecution.put(a, ListBuffer())</span>
    }

<span class="fc" id="L36">    indexAtomPartialStateExecution.get(a).get += pe</span>
  }

  def removeFromExecutionIndex(atom:Atom) {
<span class="fc bfc" id="L40" title="All 2 branches covered.">    if(indexAtomPartialStateExecution.contains(atom)) {</span>
<span class="fc" id="L41">      indexAtomPartialStateExecution.get(atom).get.foreach( pse =&gt; {</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">        if(pse.isFinal())</span>
<span class="fc" id="L43">          pse.state.rule.removeFinalExecution(pse)</span>
<span class="fc" id="L44">        pse.state.executions -= pse</span>
      })
<span class="fc" id="L46">      indexAtomPartialStateExecution.remove(atom)</span>
    }
  }

  def executeRules() {
<span class="fc bfc" id="L51" title="All 2 branches covered.">    while (rules.exists(r =&gt; r.execute)) {}</span>
  }

<span class="fc" id="L54">  def introduceAtom(atom: Atom) {</span>
<span class="fc" id="L55">    solution.addAtom(atom)</span>

<span class="pc bpc" id="L57" title="4 of 8 branches missed.">    mapAtomRules.get(atom.relation.name) match {</span>
<span class="fc" id="L58">      case s:Some[ListBuffer[NormalRule]] =&gt; s.get.foreach( r =&gt; r.addToExecution(atom))</span>
      case None =&gt;
    }
  }

  def removeAtom(atom: Atom) {
<span class="fc" id="L64">    solution.removeAtom(atom)</span>
  }

<span class="fc" id="L67">  val mapAtomRules:HashMap[String, ListBuffer[NormalRule]] = HashMap()</span>

<span class="nc" id="L69">  object NormalRule {</span>

    def createPartialStateExecution (atoms:ListBuffer[Atom], state:PartialState) =
<span class="nc" id="L72">      new PartialStateExecution(atoms, state)</span>
  }
}

<span class="pc" id="L76">class NormalRule(val head: List[Atom], val body: List[Atom], val guard: Guard, scope: Set[Variable], var engine:NormalEngine)</span>
  extends Rule {



<span class="fc" id="L81">  var variableNameList:List[String] = List()</span>
<span class="pc" id="L82">  var mapOfAtoms:HashMap[String, ListBuffer[Atom]] = HashMap()</span>

<span class="pc" id="L84">  var stateMachinesPerAtom:HashMap[String, ListBuffer[PartialState]] = HashMap()</span>
<span class="pc" id="L85">  var finalExecutionPerAtom:HashMap[String, ListBuffer[PartialStateExecution]] = HashMap()</span>

<span class="pc bpc" id="L87" title="1 of 2 branches missed.">  head.foreach( a =&gt; {</span>

    // add all the variables to the needVariableList
<span class="pc bpc" id="L90" title="2 of 4 branches missed.">    a.patterns.foreach( p =&gt; p match {</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">      case v:Variable =&gt; if(!variableNameList.contains(v.name))</span>
<span class="fc" id="L92">        variableNameList = v.name :: variableNameList</span>
      case _ =&gt;
    })

<span class="fc bfc" id="L96" title="All 2 branches covered.">    if (!mapOfAtoms.contains(a.relation.name))</span>
<span class="fc" id="L97">      mapOfAtoms.put(a.relation.name, ListBuffer())</span>

<span class="fc" id="L99">    mapOfAtoms.get(a.relation.name).get += a</span>
    // create the
  })

  // construction of the partial state machines
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">  mapOfAtoms.foreach(c =&gt; {</span>
<span class="fc" id="L105">    var permutations = c._2.permutations.toList</span>
<span class="fc" id="L106">    var states:ListBuffer[PartialState] = ListBuffer()</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">    permutations.foreach(p =&gt; {</span>
<span class="fc" id="L108">      states += new PartialState(p.toList, ListBuffer(), this, c._1)</span>
    })
<span class="fc" id="L110">    stateMachinesPerAtom.put(c._1, states)</span>

<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (!engine.mapAtomRules.contains(c._1))</span>
<span class="fc" id="L113">      engine.mapAtomRules.put(c._1, ListBuffer[NormalRule]())</span>
<span class="fc" id="L114">    engine.mapAtomRules.get(c._1).get += this</span>
  })

<span class="fc" id="L117">  def addFinalExecution(pe:PartialStateExecution) {</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">    if (!finalExecutionPerAtom.contains(pe.state.atomName))</span>
<span class="fc" id="L119">      finalExecutionPerAtom.put(pe.state.atomName, ListBuffer())</span>

<span class="fc" id="L121">    finalExecutionPerAtom.get(pe.state.atomName).get += pe</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">    if(finalExecutionPerAtom.get(pe.state.atomName).get.size &gt; 30) {</span>
<span class="fc" id="L124">      execute()</span>
    }
  }

  def removeFinalExecution(pe:PartialStateExecution) {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">    if (finalExecutionPerAtom.contains(pe.state.atomName))</span>
<span class="fc" id="L130">      finalExecutionPerAtom.get(pe.state.atomName).get -= pe</span>
  }

  def addToExecution(atom:Atom) {
<span class="fc" id="L134">    stateMachinesPerAtom.get(atom.relation.name).get.foreach {s =&gt; s.addAtomToExecutions(atom)}</span>
  }

  def clean(atom:Atom) {

<span class="fc" id="L139">    engine.removeFromExecutionIndex(atom)</span>
  }

  def canBeOk(solution:Solution):Boolean = {

<span class="fc" id="L144">    mapOfAtoms.forall( c =&gt; {</span>

<span class="pc bpc" id="L146" title="3 of 8 branches missed.">      solution.indexOfAtoms.get(c._1) != None &amp;&amp; solution.indexOfAtoms.get(c._1).get.size &gt;= c._2.size</span>
    } )
  }

  def findOneCombination(solution:Solution, combination:ListBuffer[Atom], guard:Guard):Boolean = {

<span class="fc" id="L152">    var executed = false</span>

    def flattenCombination(listOfPartialStates:List[PartialStateExecution]):Valuation =
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">      listOfPartialStates.foldLeft(Valuation()) { case(v,c) =&gt; v.union(c.vals) }</span>

    def isOneMatchingCombination(listOfPartialStates:List[PartialStateExecution]):Boolean =
<span class="pc bpc" id="L158" title="4 of 8 branches missed.">      listOfPartialStates.foldLeft(Valuation()) { case(v,c) =&gt; v.union(c.vals) } match {</span>
<span class="fc" id="L159">        case BottomValuation =&gt; false</span>
<span class="fc" id="L160">        case _ =&gt; true</span>
      }

<span class="fc" id="L163">    var listsOfListOfPartialExecution:ListBuffer[ListBuffer[PartialStateExecution]] = ListBuffer()</span>

    // A, B, C ....
<span class="pc bpc" id="L166" title="2 of 4 branches missed.">    if(finalExecutionPerAtom.forall {c =&gt; c._2.size&gt;0} ) {</span>
<span class="fc" id="L167">      finalExecutionPerAtom.foreach {c =&gt; {</span>
<span class="fc" id="L168">        listsOfListOfPartialExecution += c._2;</span>
      }}
    }

<span class="fc" id="L172">    val combination:Combinatory[PartialStateExecution] = Combinatory.from(listsOfListOfPartialExecution)</span>



<span class="pc bpc" id="L176" title="1 of 2 branches missed.">    if(combination != null) {</span>
<span class="pc bpc" id="L177" title="4 of 6 branches missed.">      var continue = combination.get() != Nil</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">      while(continue) {</span>
<span class="fc" id="L180">        val listOfPartialExecution:List[PartialStateExecution] = combination.get()</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if(isOneMatchingCombination(listOfPartialExecution)) {</span>
<span class="fc" id="L182">          var result:Valuation= flattenCombination(listOfPartialExecution)</span>
<span class="fc" id="L183">          var i = Atom.atomCount</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">          if(guard.eval(result)) {</span>
<span class="fc" id="L185">            applyReaction(listOfPartialExecution, result)</span>
<span class="fc" id="L186">            executed = true</span>
<span class="fc" id="L187">            continue = false</span>
          }
          else {
<span class="fc" id="L190">            combination.next()</span>
<span class="pc bpc" id="L191" title="3 of 6 branches missed.">            continue = combination.get() != Nil</span>
          }
        }
        else {
<span class="fc" id="L195">          combination.next()</span>
<span class="pc bpc" id="L196" title="3 of 6 branches missed.">          continue = combination.get() != Nil</span>
        }
      }
    }

<span class="fc" id="L201">    executed</span>
  }

<span class="nc" id="L204">  def getValuation(listOfAtoms:ListBuffer[Atom]):Valuation = Valuation()</span>

<span class="nc" id="L206">  def receiveUpdate(atom: Atom) {</span>
  }

  override def execute() = {
<span class="fc bfc" id="L210" title="All 4 branches covered.">    var result = canBeOk(engine.solution) &amp;&amp; findOneCombination(engine.solution, ListBuffer[Atom](), guard)</span>
<span class="fc" id="L211">    result</span>
  }

  def applyReaction(pes:List[PartialStateExecution], valuation:Valuation) {


<span class="pc bpc" id="L217" title="1 of 2 branches missed.">    pes.foreach( pe =&gt; {</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">      pe.atoms.foreach(a =&gt; {</span>
<span class="fc" id="L219">        clean(a)</span>
<span class="fc" id="L220">        engine.removeAtom(a)</span>
      })
<span class="fc" id="L222">      pe.state.removeExecution(pe)</span>
    })

<span class="fc" id="L225">    val newAtoms = this.body.map(_.applyValuation(valuation))</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">    newAtoms.foreach(a =&gt; engine.reactionStrategy.applyReaction(engine, a))</span>
//    println(i)
//    i+=1
//    engine.isRunning = true
<span class="fc" id="L231">    engine.executeRules()</span>
  }
}

<span class="pc" id="L235">class PartialStateExecution (var atoms:ListBuffer[Atom], var state:PartialState){</span>

<span class="fc" id="L237">  def copy():PartialStateExecution = new PartialStateExecution(atoms.clone(), state)</span>

  def computeValuation() {
<span class="fc" id="L240">    var result = Valuation()</span>
<span class="fc" id="L241">    atoms.zip(state.pattern).foreach( c =&gt; {</span>
<span class="fc" id="L242">      result = result.union(c._2.getValuation(c._1))</span>
    })
<span class="fc" id="L244">    isCorrect = true</span>
<span class="fc" id="L245">    vals = result</span>
  }

<span class="fc" id="L248">  def addAtom(atom:Atom){</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    if(atoms.size &lt; state.pattern.size) {</span>
<span class="fc" id="L250">      atoms += atom</span>
<span class="fc" id="L251">      this.state.rule.engine.addToExecutionIndex(atom, this)</span>
    }

<span class="fc bfc" id="L254" title="All 2 branches covered.">    if(isFinal()) {</span>
<span class="fc" id="L255">      computeValuation()</span>

      // check if valuation is empty and variables were exepected
<span class="pc bpc" id="L258" title="4 of 8 branches missed.">      if(vals == Valuation() &amp;&amp; state.variablesName.size&gt;0)</span>
<span class="nc" id="L259">        state.removeExecution(this)</span>
      else
<span class="fc" id="L261">        state.addFinalExecution(this)</span>
    }
  }

<span class="nc" id="L265">  override def toString():String = atoms.mkString(&quot;[&quot;,&quot;,&quot;,&quot;]&quot;)</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">  def isFinal():Boolean = atoms.size == state.pattern.size</span>

<span class="pc" id="L269">  var isCorrect = true</span>
<span class="fc" id="L270">  var vals = Valuation()</span>

}

<span class="pc" id="L274">class PartialState (var pattern:List[Atom], var executions:ListBuffer[PartialStateExecution] = ListBuffer(), var rule:NormalRule, var atomName:String) {</span>

<span class="pc" id="L276">  var finalExecutions:ListBuffer[PartialStateExecution] = ListBuffer()</span>



  def addFinalExecution(pse:PartialStateExecution) {
<span class="fc" id="L281">    rule.addFinalExecution(pse)</span>
  }

  def removeExecution(pse:PartialStateExecution) {
<span class="fc" id="L285">    rule.removeFinalExecution(pse)</span>
  }

  def addAtomToExecutions(atom:Atom){

<span class="fc" id="L290">    var listOfCopies:ListBuffer[PartialStateExecution] = ListBuffer()</span>
<span class="pc bpc" id="L291" title="1 of 4 branches missed.">    executions.foreach {e =&gt; if (!e.isFinal()) {</span>
<span class="fc" id="L292">      var copy = e.copy()</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">      e.atoms.foreach(a =&gt; rule.engine.addToExecutionIndex(a, copy))</span>
<span class="fc" id="L294">      listOfCopies += copy</span>
<span class="fc" id="L295">      e.addAtom(atom)</span>
    }}

<span class="fc" id="L298">    executions.insertAll(0,listOfCopies)</span>

<span class="fc" id="L300">    val pse = new PartialStateExecution(ListBuffer(), this)</span>
<span class="fc" id="L301">    pse.addAtom(atom)</span>
<span class="fc" id="L302">    executions += pse</span>
  }

<span class="pc" id="L305">  var variablesName:ListBuffer[String] = ListBuffer()</span>

<span class="pc bpc" id="L307" title="1 of 2 branches missed.">  pattern.foreach( a =&gt; {</span>

    // add all the variables to the needVariableList
<span class="pc bpc" id="L310" title="2 of 4 branches missed.">    a.patterns.foreach( p =&gt; p match {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">      case v:Variable =&gt; if(!variablesName.contains(v.name))</span>
<span class="fc" id="L312">        variablesName += v.name</span>
<span class="nc" id="L313">      case _ =&gt;</span>
    })
  } )
}

<span class="pc bnc" id="L318" title="All 4 branches missed.">class NormalCham extends NormalEngine {</span>

<span class="fc" id="L320">  def rules(ruleDefs:(RuleFactory =&gt; Rule)*) { initRules(ruleDefs.toList) }</span>
}

<span class="fc" id="L323">class Solution {</span>
<span class="pc" id="L324">  var listOfAtoms:ListBuffer[Atom] = ListBuffer()</span>
<span class="pc" id="L325">  var indexOfAtoms:HashMap[String, ListBuffer[Atom]] = HashMap()</span>

  def addAtom(atom: Atom) {
<span class="fc" id="L328">    listOfAtoms += atom</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">    if(!indexOfAtoms.contains(atom.relation.name))</span>
<span class="fc" id="L331">      indexOfAtoms.put(atom.relation.name, ListBuffer())</span>

<span class="fc" id="L333">    indexOfAtoms.get(atom.relation.name).get += atom</span>
  }

  def removeAtom(atom: Atom) {
<span class="fc" id="L337">    listOfAtoms -= (atom)</span>

<span class="fc" id="L339">    indexOfAtoms.get(atom.relation.name).get -= atom</span>
  }

<span class="nc bnc" id="L342" title="All 8 branches missed.">  def containsAll(listOfAtoms:List[Atom]):Boolean = listOfAtoms.forall( a =&gt; indexOfAtoms.contains(a.relation.name) &amp;&amp; !indexOfAtoms.get(a.relation.name).get.forall(abis =&gt; !abis.correspondsTo(a)))</span>
}

<span class="fc" id="L345">object Combinatory {</span>

  def from[A](list:ListBuffer[ListBuffer[A]]):Combinatory[A] = {

    def from_list(list:ListBuffer[A]):Combinatory[A] = {
<span class="fc" id="L350">      new Combinatory[A](list, null)</span>
    }

<span class="fc" id="L353">    var firstPointer:Combinatory[A] = null</span>
<span class="fc" id="L354">    var currentPointer:Combinatory[A] = null</span>

<span class="fc" id="L356">    list.foreach(l =&gt; {</span>
<span class="fc" id="L357">      val newCombinatory:Combinatory[A] = from_list(l)</span>

<span class="fc bfc" id="L359" title="All 2 branches covered.">      if(firstPointer == null)</span>
<span class="fc" id="L360">        firstPointer = newCombinatory</span>

<span class="fc bfc" id="L362" title="All 2 branches covered.">      if(currentPointer != null)</span>
<span class="fc" id="L363">        currentPointer.comb = newCombinatory</span>

<span class="fc" id="L365">      currentPointer = newCombinatory</span>
    })

<span class="fc" id="L368">    firstPointer</span>
  }
}

<span class="pc" id="L372">class Combinatory[A](var list:ListBuffer[A] = ListBuffer(), var comb:Combinatory[A] = null) {</span>
<span class="fc" id="L373">  var index:Int = 0</span>

  def reset() {
<span class="fc" id="L376">    index = 0</span>
  }

  // index is superior or equal to the list's size
<span class="fc bfc" id="L380" title="All 2 branches covered.">  def isOverflowed():Boolean = index &gt;= list.size</span>

  def next() {
<span class="fc bfc" id="L383" title="All 2 branches covered.">    if(comb != null) {</span>
<span class="fc" id="L384">      var truc = isOverflowed()</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">      if(!(isOverflowed())) {</span>
<span class="fc" id="L386">        comb.next()</span>

<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (comb.isOverflowed()) {</span>
<span class="fc" id="L389">          comb.reset()</span>
<span class="fc" id="L390">          index += 1</span>
        }
      }
    }
    else {
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">      if (!isOverflowed()) {</span>
<span class="fc" id="L396">        index += 1</span>
      }
    }
  }

  def get():List[A] = {
<span class="fc bfc" id="L402" title="All 2 branches covered.">    if(!(isOverflowed())) {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">      if(comb != null) {</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if(!comb.isOverflowed()) {</span>
<span class="fc" id="L405">          list(index) :: comb.get()</span>
        }
        else {
<span class="nc" id="L408">          Nil</span>
        }
      }
      else {
<span class="fc" id="L412">        List(list(index))</span>
      }
    }
    else {
<span class="fc" id="L416">      Nil</span>
    }
  }

  def hasNext():Boolean = {
<span class="nc bnc" id="L421" title="All 2 branches missed.">    if(comb != null) {</span>
<span class="nc bnc" id="L422" title="All 4 branches missed.">      !isOverflowed() || comb.hasNext()</span>
    }
    else {
<span class="nc bnc" id="L425" title="All 2 branches missed.">      !isOverflowed()</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://jacoco.org">JaCoCo</a> 0.5.3.201107060350</span></div></body></html>